PG_MAJOR?=11
PGVERSION=pg$(PG_MAJOR)
POSTGIS_VERSIONS?="2.5 3"

# CI/CD can benefit from specifying a specific apt packages mirror
DEBIAN_REPO_MIRROR?=""

# These variables have to do with this Docker repository
GIT_COMMIT=$(shell git describe --always --tag --long --abbrev=8)
GIT_BRANCH=$(shell git symbolic-ref --short HEAD)
GIT_REMOTE=$(shell git config --get remote.origin.url | sed 's/.*@//g')
GIT_STATUS=$(shell git status --porcelain | paste -sd "," -)
GIT_AUTHOR?=$(USER)
GIT_REV?=$(shell git rev-parse HEAD)

# These variables have to do with what software we pull in from github
GITHUB_USER?=""
GITHUB_TOKEN?=""
GITHUB_REPO?="timescale/timescaledb"
GITHUB_TAG?="master"

TAG?=$(subst /,_,$(GIT_BRANCH)-$(GIT_COMMIT))
REGISTRY?=localhost:5000
TIMESCALEDB_REPOSITORY?=timescale/timescaledb-docker-ha
TIMESCALEDB_IMAGE?=$(REGISTRY)/$(TIMESCALEDB_REPOSITORY)
TIMESCALEDB_BUILDER_URL?=$(TIMESCALEDB_IMAGE):builder-$(PGVERSION)
TIMESCALEDB_RELEASE_URL?=$(TIMESCALEDB_IMAGE):$(TAG)-$(PGVERSION)
TIMESCALEDB_LATEST_URL?=$(TIMESCALEDB_IMAGE):latest-$(PGVERSION)
PG_PROMETHEUS?=0.2.2
INSTALL_METHOD?="docker-ha"

CICD_REPOSITORY=registry.gitlab.com/timescale/timescaledb-docker-ha
DOCKER_HUB_REPOSITORY=localhost:32000/timescaledev/timescaledb-ha

build:         POSTFIX   = 
build: 		   BUILDARGS =
build-oss:     POSTFIX   = -oss
build-oss:	   BUILDARGS = --build-arg OSS_ONLY=" -DAPACHE_ONLY=1"
build-postgis: POSTFIX   = -postgis
build-postgis: BUILDARGS = --build-arg POSTGIS_VERSIONS=$(POSTGIS_VERSIONS)
build-tag:	   POSTFIX   =
build-tag: 	   BUILDARGS = --build-arg GITHUB_REPO=$(GITHUB_REPO) --build-arg GITHUB_USER=$(GITHUB_USER) --build-arg GITHUB_TOKEN=$(GITHUB_TOKEN) --build-arg GITHUB_TAG=$(GITHUB_TAG)

# We label all the Docker Images with the versions of PostgreSQL, TimescaleDB and other extensions
# that are in versions.json.
# versions.json is generated by starting a builder container and querying the PostgreSQL catalogs
# for all the version information. In that way, we are sure we never tag the Docker images with the wrong
# versions.
# I'm using $$(jq) instead of $(shell), as we need to evaluate these variables for every new image build
DOCKER_BUILD_COMMAND=docker build --build-arg PG_MAJOR=$(PG_MAJOR) \
					 --build-arg INSTALL_METHOD="$(INSTALL_METHOD)" \
					 --build-arg PG_PROMETHEUS=$(PG_PROMETHEUS) \
					 --build-arg DEBIAN_REPO_MIRROR=$(DEBIAN_REPO_MIRROR) $(DOCKER_IMAGE_CACHE) \
					 --label org.opencontainers.image.created="$$(date -Iseconds --utc)" \
					 --label org.opencontainers.image.revision="$(GIT_REV)" \
					 --label org.opencontainers.image.vendor=Timescale \
					 --label org.opencontainers.image.source="$(GIT_REMOTE)"

default: build

.PHONY: build build-postgis build-oss build-tag
build build-postgis build-oss build-tag: builder
	$(DOCKER_BUILD_COMMAND) --tag $(TIMESCALEDB_RELEASE_URL)$(POSTFIX)-wip $(BUILDARGS) .
	
	# In these steps we do some introspection to find out some details of the versions that are inside the Docker image
	# We will then attach this information as OCI labels to the final Docker image
	# https://github.com/opencontainers/image-spec/blob/master/annotations.md
	docker stop dummy$(POSTFIX) || true
	docker run -d --rm --name dummy$(POSTFIX) -e PGDATA=/tmp/pgdata --user=postgres $(TIMESCALEDB_RELEASE_URL)$(POSTFIX)-wip \
		sh -c 'initdb && timeout 30 postgres'
	docker exec -i dummy$(POSTFIX) sh -c 'while ! pg_isready; do sleep 1; done'
	cat scripts/version_info.sql | docker exec -i dummy$(POSTFIX) psql -AtXq | tee .$@
	docker stop dummy$(POSTFIX)

	# This is where we build the final Docker Image, including all the version labels
	echo "FROM $(TIMESCALEDB_RELEASE_URL)$(POSTFIX)-wip" | docker build --tag $(TIMESCALEDB_RELEASE_URL)$(POSTFIX) - \
		$$(jq 'to_entries | map("--label com.timescaledb.image.\(.key).version=\(.value)") | join(" ")' -r .$@)
	
	docker tag $(TIMESCALEDB_RELEASE_URL)$(POSTFIX) $(TIMESCALEDB_LATEST_URL)$(POSTFIX)

.PHONY: build-all
build-all: build build-postgis build-oss

# To speed up most builds, having .builder be an actual target is very useful
.builder: Dockerfile $(shell find . -type f ! -path '*.git*' ! -name '*build*')
	$(DOCKER_BUILD_COMMAND) --target builder -t $(TIMESCALEDB_BUILDER_URL) .
	touch .builder
.PHONY: builder
builder: .builder

.PHONY: push push-postgis push-oss
push push-postgis push-oss: push% : build%
	export POSTFIX=$$(echo $@ | cut -c 5-) \
	&& docker push $(TIMESCALEDB_RELEASE_URL)$${POSTFIX} \
	&& docker push $(TIMESCALEDB_LATEST_URL)$${POSTFIX}

.PHONY: push-all
push-all: push push-postgis push-oss

.PHONY: release
release:
	@echo "This operation will push new Docker images to the timescaledev public Docker hub"                              
	@echo -n "Are you sure? [y/N] " && read ans && [ $${ans:-N} = y ]
	@echo -n "For which tagged release do you wish to push the Docker images? " && read RELEASE_TAG \
	&& for variant in "" -oss -postgis; do \
		docker pull $(CICD_REPOSITORY):$${RELEASE_TAG}-pg11$${variant} \
		&& docker inspect $(CICD_REPOSITORY):$${RELEASE_TAG}-pg11$${variant} \
		| jq '.[0]."ContainerConfig"."Labels"."com.timescaledb.image.postgresql.version"' -r; \
	done


test: build-postgis
	# Very simple test that verifies the following things:
	# - PATH has the correct setting
	# - initdb succeeds
	# - timescaledb is correctly injected into the default configuration
	#
	# TODO: Create a good test-suite. For now, it's nice to have this target in CI/CD,
	# and have it do something worthwhile
	docker run --rm --tty $(TIMESCALEDB_RELEASE_URL)-postgis /bin/bash -c "initdb -D test && grep timescaledb test/postgresql.conf"

clean:
	rm -f *~ .build_* versions.json builder
